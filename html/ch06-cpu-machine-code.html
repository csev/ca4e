<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Computer Architecture for Everybody — CPU Architecture and
Machine Code: How Programs Actually Run</title>
  <link rel="stylesheet" href="book.css" />
  <style>
    body { max-width: 50em; margin: 2rem auto; padding: 0 1rem; line-height: 1.55; }
    .ca4e-nav { display:flex; gap:1rem; align-items:center; margin: 1.25rem 0; padding:.75rem 0; border-top:1px solid #ddd; border-bottom:1px solid #ddd; }
    .ca4e-spacer { flex: 1; }
    .ca4e-nav a { text-decoration:none; }
    img { max-height: 200px; width: auto; height: auto; display: block; margin: 0 auto; }
    figure { margin: 1.5em 0; }
    figcaption { text-align: center; font-style: italic; margin-top: 0.5em; }
  </style>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      var chapterNum = '6';
      
      // Only number if chapterNum is not empty (index page has empty string)
      // On index page: chapterNum will be empty string ""
      // On chapter pages: chapterNum will be "1", "2", etc.
      var isValid = chapterNum && chapterNum.trim() !== '';
      
      if (isValid) {
        var sectionNum = 0;
        var figureNum = 0;
        
        // Number h2 sections
        var h2s = document.querySelectorAll('h2');
        h2s.forEach(function(h2) {
          sectionNum++;
          var text = h2.textContent;
          h2.textContent = chapterNum + '.' + sectionNum + ' ' + text;
        });
        
        // Number figures
        var figures = document.querySelectorAll('figure');
        figures.forEach(function(fig) {
          figureNum++;
          var caption = fig.querySelector('figcaption');
          if (caption) {
            var text = caption.textContent;
            caption.innerHTML = '<strong>Figure ' + chapterNum + '.' + figureNum + ':</strong> ' + text;
          }
        });
      }
    });
  </script>
</head>
<body>
<nav class="ca4e-nav" aria-label="Chapter navigation">
<a class="ca4e-home" href="index.html">Contents</a> <span
class="ca4e-spacer"></span>
<a class="ca4e-prev" href="ch05-clocked-circuits.html">← Previous</a>
<a class="ca4e-next" href="ch07-webassembly.html">Next →</a>
</nav>
<h1 id="cpu-architecture-and-machine-code-how-programs-actually-run">CPU
Architecture and Machine Code: How Programs Actually Run</h1>
<p>Up to this point, digital systems have been built from logic gates,
storage elements, and clocked circuits. These components make it
possible to store values and perform arithmetic, but they do not yet
explain how a general-purpose machine can follow a sequence of
instructions. That capability emerges when computation is organized
around a central processing unit (CPU) that repeatedly executes a simple
control loop.</p>
<p>This chapter introduces a complete, working processor model and shows
how machine instructions drive its behavior. Programs are examined not
as abstract algorithms, but as concrete patterns of bits stored in
memory that directly control hardware.</p>
<hr />
<h2 id="from-fixed-circuits-to-programmable-machines">From Fixed
Circuits to Programmable Machines</h2>
<p>In earlier chapters, behavior was determined by wiring. If a circuit
always adds two numbers or always increments a counter, then its
function is fixed at design time. Programmable machines replace fixed
control paths with instruction-controlled behavior.</p>
<p>Instead of hardwiring what happens each cycle, instruction bits
select which operations occur and where data flows. The same physical
hardware can perform many different tasks simply by changing the
contents of memory.</p>
<p>This separation between hardware and program is the defining feature
of general-purpose computers.</p>
<hr />
<h2 id="a-simple-but-complete-cpu">A Simple but Complete CPU</h2>
<figure>
<img src="images/ch06-cpu-block-diagram.png"
alt="Block diagram of the CDC6504-style CPU" />
<figcaption aria-hidden="true">Block diagram of the CDC6504-style
CPU</figcaption>
</figure>
<p>A minimal but realistic processor can be built from the following
components:</p>
<ul>
<li><strong>Registers</strong> that store temporary values<br />
</li>
<li>a <strong>Program Counter (PC)</strong> that holds the address of
the next instruction<br />
</li>
<li>an <strong>Instruction Register (IR)</strong> that holds the current
instruction<br />
</li>
<li>an <strong>Arithmetic Logic Unit (ALU)</strong> that performs
arithmetic and logic<br />
</li>
<li><strong>Memory</strong> that stores both instructions and data<br />
</li>
<li><strong>Control logic</strong> that interprets instruction bits</li>
</ul>
<p>The CDC6504 emulator used in this book models a processor inspired by
early microprocessors, with a small number of registers and a compact
instruction set. Despite its simplicity, it contains all of the
essential elements found in modern CPUs.</p>
<hr />
<h2 id="registers-fast-small-storage">Registers: Fast, Small
Storage</h2>
<p>Registers are small storage locations located directly inside the
CPU. They are much faster to access than memory and are used to hold
intermediate results during computation.</p>
<p>Typical registers include:</p>
<ul>
<li>an <strong>Accumulator (A)</strong> for arithmetic results<br />
</li>
<li>index registers such as <strong>X</strong> and <strong>Y</strong>
for addressing and looping<br />
</li>
<li>a <strong>Status register</strong> that holds condition flags</li>
</ul>
<p>Flags record results of previous operations, such as whether a value
was zero or whether an arithmetic overflow occurred. Later instructions
can examine these flags to make decisions.</p>
<figure>
<img src="images/ch06-registers-flags.png"
alt="CPU register set and status flags" />
<figcaption aria-hidden="true">CPU register set and status
flags</figcaption>
</figure>
<hr />
<h2 id="memory-where-programs-and-data-live">Memory: Where Programs and
Data Live</h2>
<p>Memory stores both instructions and data as sequences of bytes. Each
byte is located at an address, and the Program Counter specifies which
address should be read next.</p>
<p>Although modern computers often separate instruction and data memory
internally, most early processors—and many simple designs—use a single
memory space for both. In such systems, instructions are simply data
that the CPU interprets in a special way.</p>
<p>This is why programs can be modified, copied, and even generated by
other programs.</p>
<hr />
<h2 id="the-fetchdecodeexecute-cycle">The Fetch–Decode–Execute
Cycle</h2>
<p>Every instruction executed by the CPU follows the same basic
sequence:</p>
<ol type="1">
<li><strong>Fetch</strong> the instruction from memory using the Program
Counter<br />
</li>
<li><strong>Decode</strong> the instruction to determine what operation
to perform<br />
</li>
<li><strong>Execute</strong> the operation using the ALU and
registers<br />
</li>
<li><strong>Update</strong> the Program Counter to the next
instruction</li>
</ol>
<p>This loop repeats continuously while the program runs.</p>
<figure>
<img src="images/ch06-fde-detailed.png"
alt="Fetch-decode-execute cycle with PC, IR, and control signals" />
<figcaption aria-hidden="true">Fetch-decode-execute cycle with PC, IR,
and control signals</figcaption>
</figure>
<p>Clock signals coordinate each stage so that values are stable when
they are stored or used.</p>
<hr />
<h2 id="why-hexadecimal-is-used">Why Hexadecimal Is Used</h2>
<p>Machine instructions are sequences of bits, but long binary strings
are difficult for humans to read. Hexadecimal notation groups bits into
sets of four, making memory contents easier to inspect and write.</p>
<p>For example:</p>
<ul>
<li>binary: <code>1010 1111</code><br />
</li>
<li>hex: <code>AF</code></li>
</ul>
<p>Each hexadecimal digit corresponds exactly to four binary bits. This
mapping makes it convenient to display memory as rows of hex values
while still representing precise machine data.</p>
<p>Assemblers, debuggers, and emulators commonly display memory using
hexadecimal for this reason.</p>
<figure>
<img src="images/ch06-hex-memory.png"
alt="Memory display showing hexadecimal values" />
<figcaption aria-hidden="true">Memory display showing hexadecimal
values</figcaption>
</figure>
<hr />
<h2 id="instruction-formats-and-operands">Instruction Formats and
Operands</h2>
<p>Each machine instruction contains:</p>
<ul>
<li>an <strong>opcode</strong> that specifies the operation<br />
</li>
<li>zero or more <strong>operands</strong> that specify data or
addresses</li>
</ul>
<p>Some instructions operate directly on registers, while others
reference memory. Common addressing modes include:</p>
<ul>
<li><strong>Immediate</strong>: value is part of the instruction<br />
</li>
<li><strong>Direct</strong>: instruction contains a memory address<br />
</li>
<li><strong>Indexed</strong>: address is computed using a register plus
an offset</li>
</ul>
<p>Different addressing modes allow programs to work with arrays,
tables, and strings efficiently.</p>
<figure>
<img src="images/ch06-instruction-format.png"
alt="Instruction format and addressing modes" />
<figcaption aria-hidden="true">Instruction format and addressing
modes</figcaption>
</figure>
<hr />
<h2 id="control-logic-and-decoding">Control Logic and Decoding</h2>
<p>Instruction decoding is performed by control logic that converts
opcode bits into control signals. These signals determine:</p>
<ul>
<li>which registers receive data<br />
</li>
<li>whether the ALU performs addition, subtraction, or comparison<br />
</li>
<li>whether memory is read or written<br />
</li>
<li>whether the Program Counter is modified</li>
</ul>
<p>Conceptually, decoding is a large decision tree built from logic
gates. In real processors, this logic is carefully optimized to minimize
delay along critical paths.</p>
<p>Although decoding may appear complex, it is simply a systematic
application of digital logic to route signals correctly.</p>
<hr />
<h2 id="sequential-flow-branches-and-loops">Sequential Flow, Branches,
and Loops</h2>
<p>By default, the Program Counter advances to the next instruction
after each cycle, causing instructions to execute sequentially. Branch
instructions modify the Program Counter based on conditions stored in
status flags.</p>
<p>This makes loops possible:</p>
<ol type="1">
<li>perform an operation<br />
</li>
<li>test a condition<br />
</li>
<li>branch back if the condition is not yet met</li>
</ol>
<p>All higher-level control structures—such as while loops and if
statements—ultimately reduce to conditional branches that alter the
Program Counter.</p>
<figure>
<img src="images/ch06-branch-flow.png"
alt="Branch instruction modifying program flow" />
<figcaption aria-hidden="true">Branch instruction modifying program
flow</figcaption>
</figure>
<hr />
<h2 id="example-counting-with-a-loop">Example: Counting with a Loop</h2>
<p>Consider a simple loop that increments a register until it reaches a
limit. In assembly language, this might look like:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">LOAD</span> A<span class="op">,</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">LOOP:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span>  A<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">CMP</span>  A<span class="op">,</span> <span class="op">#</span><span class="dv">10</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>BNE  LOOP</span></code></pre></div>
<p>Each line corresponds to one or more machine instructions. During
execution, the Program Counter repeatedly jumps back to the label until
the condition is satisfied.</p>
<p>At the hardware level, this behavior is nothing more than controlled
updates to registers and the Program Counter on each clock cycle.</p>
<hr />
<h2 id="assembly-language-as-a-human-interface">Assembly Language as a
Human Interface</h2>
<p>Machine code is difficult to write directly. Assembly language
provides symbolic names for instructions and allows labels to represent
addresses. An <strong>assembler</strong> translates these symbolic
programs into machine code.</p>
<p>Assembly language does not add new capabilities to the machine. It
merely makes programs easier to write and understand.</p>
<figure>
<img src="images/ch06-assembler.png"
alt="Assembly source translated into machine code by an assembler" />
<figcaption aria-hidden="true">Assembly source translated into machine
code by an assembler</figcaption>
</figure>
<p>For educational purposes, writing small programs in assembly reveals
exactly how software controls hardware.</p>
<hr />
<h2 id="strings-characters-and-memory">Strings, Characters, and
Memory</h2>
<p>Characters are stored as numeric codes, such as ASCII values. A
string is simply a sequence of character codes stored in memory.</p>
<p>Programs that process text operate by:</p>
<ul>
<li>loading a character from memory<br />
</li>
<li>testing or modifying it<br />
</li>
<li>storing it back</li>
</ul>
<p>Operations such as converting letters to uppercase are performed by
arithmetic on character codes, not by any special text-handling
hardware.</p>
<p>This illustrates that all data—numbers, characters, images—are
treated uniformly as binary values by the processor.</p>
<hr />
<h2 id="from-python-to-machine-instructions">From Python to Machine
Instructions</h2>
<p>High-level languages such as Python hide hardware details, but their
execution still depends on machine instructions.</p>
<p>A loop written in Python becomes:</p>
<ul>
<li>comparisons<br />
</li>
<li>branches<br />
</li>
<li>register updates</li>
</ul>
<p>at the machine level. Although modern systems add layers such as
virtual machines and just-in-time compilation, the final execution
always reduces to instructions executed by hardware.</p>
<p>Understanding machine code provides insight into performance, memory
usage, and the real cost of software operations.</p>
<hr />
<h2 id="why-this-model-still-matters">Why This Model Still Matters</h2>
<p>Modern processors are far more complex than early microprocessors,
with multiple cores, deep pipelines, and sophisticated memory systems.
However, they still execute programs using the same fundamental
principles:</p>
<ul>
<li>fetch instructions<br />
</li>
<li>decode operations<br />
</li>
<li>manipulate registers and memory<br />
</li>
<li>update the Program Counter</li>
</ul>
<p>The complexity lies in doing many of these steps in parallel and at
extremely high speeds, not in changing the basic execution model.</p>
<p>Learning a small, complete CPU provides a foundation for
understanding much larger systems.</p>
<hr />
<h2 id="summary-programs-are-physical-processes">Summary: Programs Are
Physical Processes</h2>
<p>Programs are not abstract mathematical objects running in isolation.
They are physical processes enacted by electrical signals moving through
circuits, coordinated by clocks, and shaped by control logic.</p>
<p>Machine instructions directly control data paths and storage
elements. Assembly language offers a symbolic view of these
instructions, while high-level languages build additional layers of
abstraction on top.</p>
<p>By examining how a complete processor executes real programs, the
relationship between hardware and software becomes concrete and
observable.</p>
<hr />
<h2 id="what-comes-next">What Comes Next</h2>
<p>With a complete CPU model in place, attention can now turn to how
real-world processors improve performance through techniques such as
pipelining, caching, and parallel execution. The next chapter explores
how architectural enhancements build on the same foundations while
dramatically increasing speed.</p>
<nav class="ca4e-nav" aria-label="Chapter navigation">
<a class="ca4e-home" href="index.html">Contents</a> <span
class="ca4e-spacer"></span>
<a class="ca4e-prev" href="ch05-clocked-circuits.html">← Previous</a>
<a class="ca4e-next" href="ch07-webassembly.html">Next →</a>
</nav>
</body>
</html>
