# CPU Architecture and Machine Code: How Programs Actually Run

\index{CPU}\index{machine code}\index{CDC6504}

Up to this point, digital systems have been built from logic gates, storage elements, and clocked circuits. These components make it possible to store values and perform arithmetic, but they do not yet explain how a general-purpose machine can follow a sequence of instructions. That capability emerges when computation is organized around a central processing unit (CPU)\index{CPU} that repeatedly executes a simple control loop.

This chapter introduces a complete, working processor model and shows how machine instructions\index{machine code} drive its behavior. Programs are examined not as abstract algorithms, but as concrete patterns of bits stored in memory that directly control hardware.

---

## From Fixed Circuits to Programmable Machines

In earlier chapters, behavior was determined by wiring. If a circuit always adds two
numbers or always increments a counter, then its function is fixed at design time.
Programmable machines replace fixed control paths with instruction-controlled behavior.

Instead of hardwiring what happens each cycle, instruction bits select which operations
occur and where data flows. The same physical hardware can perform many different tasks
simply by changing the contents of memory.

This separation between hardware and program is the defining feature of general-purpose
computers.

---

## A Simple but Complete CPU

![Block diagram of the CDC6504-style CPU](images/ch06-cpu-block-diagram.png)

A minimal but realistic processor can be built from the following components:

- **Registers**\index{registers} that store temporary values  
- a **Program Counter (PC)**\index{Program Counter} that holds the address of the next instruction  
- an **Instruction Register (IR)**\index{Instruction Register} that holds the current instruction  
- an **Arithmetic Logic Unit (ALU)**\index{ALU} that performs arithmetic and logic  
- **Memory**\index{memory} that stores both instructions and data  
- **Control logic**\index{control logic} that interprets instruction bits  

The CDC6504 emulator\index{CDC6504} used in this book models a processor inspired by early microprocessors, with a small number of registers and a compact instruction set. Despite its simplicity, it contains all of the essential elements found in modern CPUs.

---

## Registers: Fast, Small Storage

Registers\index{registers} are small storage locations located directly inside the CPU. They are much faster to access than memory and are used to hold intermediate results during computation.

Typical registers include:

- an **Accumulator (A)**\index{Accumulator} for arithmetic results  
- index registers such as **X** and **Y** for addressing and looping  
- a **Status register**\index{status register} that holds condition flags\index{flags}  

Flags record results of previous operations, such as whether a value was zero or whether
an arithmetic overflow occurred. Later instructions can examine these flags to make
decisions.

![CPU register set and status flags](images/ch06-registers-flags.png)

---

## Memory: Where Programs and Data Live

Memory stores both instructions and data as sequences of bytes. Each byte is located at an
address, and the Program Counter specifies which address should be read next.

Although modern computers often separate instruction and data memory internally, most
early processors—and many simple designs—use a single memory space for both. In such
systems, instructions are simply data that the CPU interprets in a special way.

This is why programs can be modified, copied, and even generated by other programs.

---

## The Fetch–Decode–Execute Cycle

Every instruction executed by the CPU follows the same basic sequence:

1. **Fetch** the instruction from memory using the Program Counter  
2. **Decode** the instruction to determine what operation to perform  
3. **Execute** the operation using the ALU and registers  
4. **Update** the Program Counter to the next instruction  

This loop\index{fetch-decode-execute cycle} repeats continuously while the program runs.

![Fetch-decode-execute cycle with PC, IR, and control signals](images/ch06-fde-detailed.png)

Clock signals coordinate each stage so that values are stable when they are stored or
used.

---

## Why Hexadecimal Is Used

Machine instructions are sequences of bits, but long binary strings are difficult for humans to read. Hexadecimal notation\index{hexadecimal} groups bits into sets of four, making memory contents easier to inspect and write.

For example:

- binary: `1010 1111`  
- hex: `AF`  

Each hexadecimal digit corresponds exactly to four binary bits. This mapping makes it
convenient to display memory as rows of hex values while still representing precise
machine data.

Assemblers\index{assembler}, debuggers, and emulators commonly display memory using hexadecimal for this reason.

![Memory display showing hexadecimal values](images/ch06-hex-memory.png)

---

## Instruction Formats and Operands

Each machine instruction contains:

- an **opcode**\index{opcode} that specifies the operation  
- zero or more **operands**\index{operands} that specify data or addresses  

Some instructions operate directly on registers, while others reference memory. Common addressing modes\index{addressing modes} include:

- **Immediate**\index{immediate addressing}: value is part of the instruction  
- **Direct**\index{direct addressing}: instruction contains a memory address  
- **Indexed**\index{indexed addressing}: address is computed using a register plus an offset  

Different addressing modes allow programs to work with arrays, tables, and strings
efficiently.

![Instruction format and addressing modes](images/ch06-instruction-format.png)

---

## Control Logic and Decoding

Instruction decoding is performed by control logic that converts opcode bits into control
signals. These signals determine:

- which registers receive data - whether the ALU performs addition, subtraction, or
comparison - whether memory is read or written - whether the Program Counter is modified

Conceptually, decoding is a large decision tree built from logic gates. In real
processors, this logic is carefully optimized to minimize delay along critical paths.

Although decoding may appear complex, it is simply a systematic application of digital
logic to route signals correctly.

---

## Sequential Flow, Branches, and Loops

By default, the Program Counter advances to the next instruction after each cycle, causing
instructions to execute sequentially. Branch instructions modify the Program Counter based
on conditions stored in status flags.

This makes loops possible:

1. perform an operation 2. test a condition 3. branch back if the condition is not yet met

All higher-level control structures—such as while loops and if statements—ultimately
reduce to conditional branches that alter the Program Counter.

![Branch instruction modifying program flow](images/ch06-branch-flow.png)

---

## Example: Counting with a Loop

Consider a simple loop that increments a register until it reaches a limit. In assembly
language, this might look like:

```asm
LOAD A, #0
LOOP:
ADD  A, #1
CMP  A, #10
BNE  LOOP
```

Each line corresponds to one or more machine instructions. During execution, the Program
Counter repeatedly jumps back to the label until the condition is satisfied.

At the hardware level, this behavior is nothing more than controlled updates to registers
and the Program Counter on each clock cycle.

---

## Assembly Language as a Human Interface

Machine code is difficult to write directly. Assembly language\index{assembly language} provides symbolic names for instructions and allows labels to represent addresses. An **assembler**\index{assembler} translates these symbolic programs into machine code.

Assembly language does not add new capabilities to the machine. It merely makes programs
easier to write and understand.

![Assembly source translated into machine code by an assembler](images/ch06-assembler.png)

For educational purposes, writing small programs in assembly reveals exactly how software
controls hardware.

---

## Strings, Characters, and Memory

Characters are stored as numeric codes, such as ASCII values\index{ASCII}. A string is simply a sequence of character codes stored in memory.

Programs that process text operate by:

- loading a character from memory - testing or modifying it - storing it back

Operations such as converting letters to uppercase are performed by arithmetic on
character codes, not by any special text-handling hardware.

This illustrates that all data—numbers, characters, images—are treated uniformly as binary
values by the processor.

---

## From Python to Machine Instructions

High-level languages such as Python hide hardware details, but their execution still
depends on machine instructions.

A loop written in Python becomes:

- comparisons - branches - register updates

at the machine level. Although modern systems add layers such as virtual machines and
just-in-time compilation, the final execution always reduces to instructions executed by
hardware.

Understanding machine code provides insight into performance, memory usage, and the real
cost of software operations.

---

## Why This Model Still Matters

Modern processors are far more complex than early microprocessors, with multiple cores,
deep pipelines, and sophisticated memory systems. However, they still execute programs
using the same fundamental principles:

- fetch instructions - decode operations - manipulate registers and memory - update the
Program Counter

The complexity lies in doing many of these steps in parallel and at extremely high speeds,
not in changing the basic execution model.

Learning a small, complete CPU provides a foundation for understanding much larger
systems.

---

## Summary: Programs Are Physical Processes

Programs are not abstract mathematical objects running in isolation. They are physical
processes enacted by electrical signals moving through circuits, coordinated by clocks,
and shaped by control logic.

Machine instructions directly control data paths and storage elements. Assembly language
offers a symbolic view of these instructions, while high-level languages build additional
layers of abstraction on top.

By examining how a complete processor executes real programs, the relationship between
hardware and software becomes concrete and observable.

---

## What Comes Next

With a complete CPU model in place, attention can now turn to how real-world processors
improve performance through techniques such as pipelining, caching, and parallel
execution. The next chapter explores how architectural enhancements build on the same
foundations while dramatically increasing speed.
