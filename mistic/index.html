<h1>VLSI LAYOUT like Magic</h1>
<div id="toolbar">
    <button onclick="setLayer('polysilicon')">Polysilicon</button>
    <button onclick="setLayer('N+ diffusion')">N+ Diffusion</button>
    <button onclick="setLayer('P+ diffusion')">P+ Diffusion</button>
    <button onclick="setLayer('contact')">Contact</button>
    <button onclick="setLayer('metal')">Metal</button>
    <button onclick="setLayer('erase')">Erase</button>
    <button onclick="clearCanvas()">Clear All</button>
</div>
<canvas id="vlsiCanvas" width="400" height="400" style="border:1px solid #000000;"></canvas>

<script>
    const canvas = document.getElementById('vlsiCanvas');
    const ctx = canvas.getContext('2d');
    const tileSize = 20;
    const layers = {
        'polysilicon': 'rgba(255, 0, 0, 0.3)', // Light Red
        'N+ diffusion': 'rgba(0, 255, 0, 0.3)', // Light Green
        'P+ diffusion': 'rgba(255, 165, 0, 0.3)', // Light Orange
        'contact': 'rgba(0, 0, 0, 0.3)', // Light Black (not used for filling)
        'metal': 'rgba(0, 0, 255, 0.3)' // Light Blue
    };
    let currentLayer = '';
    let isDrawing = false;
    let startX, startY; // Track starting position
    const grid = Array(20).fill().map(() => Array(20).fill().map(() => Array(5).fill(false))); // 20x20x5 grid

    function setLayer(layer) {
        currentLayer = layer;
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        grid.forEach(row => row.forEach(col => col.fill(false))); // Reset the grid
    }

    canvas.addEventListener('mousedown', function(event) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        startX = Math.floor((event.clientX - rect.left) / tileSize);
        startY = Math.floor((event.clientY - rect.top) / tileSize);
    });

    canvas.addEventListener('mousemove', function(event) {
        if (isDrawing) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / tileSize);
            const y = Math.floor((event.clientY - rect.top) / tileSize);
            drawRubberBand(startX, startY, x, y); // Draw the rubber band effect
        }
    });

    canvas.addEventListener('mouseup', function(event) {
        isDrawing = false;
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((event.clientX - rect.left) / tileSize);
        const y = Math.floor((event.clientY - rect.top) / tileSize);
        fillTiles(startX, startY, x, y); // Fill or erase tiles once the mouse is released
        ctx.beginPath(); // Reset the path
    });

    function drawRubberBand(startX, startY, endX, endY) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        redrawAllTiles(); // Redraw all tiles to maintain their state

        // Draw the rubber band rectangle
        const x1 = Math.min(startX, endX);
        const y1 = Math.min(startY, endY);
        const x2 = Math.max(startX, endX);
        const y2 = Math.max(startY, endY);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; // Rubber band color
        ctx.lineWidth = 2;
        ctx.strokeRect(x1 * tileSize, y1 * tileSize, (x2 - x1 + 1) * tileSize, (y2 - y1 + 1) * tileSize);
    }

    function fillTiles(startX, startY, endX, endY) {
        const x1 = Math.min(startX, endX);
        const y1 = Math.min(startY, endY);
        const x2 = Math.max(startX, endX);
        const y2 = Math.max(startY, endY);

        for (let i = y1; i <= y2; i++) {
            for (let j = x1; j <= x2; j++) {
                const layerIndex = getLayerIndex(currentLayer);
                if (currentLayer === 'erase') {
                    // Erase all layers at the current tile
                    for (let k = 0; k < 5; k++) {
                        grid[i][j][k] = false; // Mark all layers as not drawn
                    }
                } else if (layerIndex !== -1) {
                    grid[i][j][layerIndex] = true; // Mark the layer as drawn
                }
            }
        }
        redrawAllTiles(); // Redraw all tiles after filling or erasing
    }

    function redrawAllTiles() {
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                redrawTile(j, i); // Redraw each tile
            }
        }
    }

    function redrawTile(x, y) {
        ctx.clearRect(x * tileSize, y * tileSize, tileSize, tileSize); // Clear the tile
        for (let i = 0; i < 5; i++) { // Loop through all layers
            if (grid[y][x][i]) {
                if (i === 3) { // If the layer is 'contact'
                    drawContactLines(x, y); // Draw the contact lines instead of filling
                } else {
                    ctx.fillStyle = Object.values(layers)[i]; // Get the color for the layer
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
        }
    }

    function drawContactLines(x, y) {
        ctx.strokeStyle = 'black'; // Color for the lines
        ctx.lineWidth = 2; // Line width
        ctx.beginPath();
        // Draw a black rectangle for the contact
        ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
        // Draw diagonal lines
        ctx.moveTo(x * tileSize, y * tileSize);
        ctx.lineTo((x + 1) * tileSize, (y + 1) * tileSize); // Top-left to bottom-right
        ctx.moveTo((x + 1) * tileSize, y * tileSize);
        ctx.lineTo(x * tileSize, (y + 1) * tileSize); // Top-right to bottom-left
        ctx.stroke();
    }

    function getLayerIndex(layer) {
        switch (layer) {
            case 'polysilicon': return 0;
            case 'N+ diffusion': return 1;
            case 'P+ diffusion': return 2;
            case 'contact': return 3;
            case 'metal': return 4;
            case 'erase': return -1; // Invalid layer for index
            default: return -1; // Invalid layer
        }
    }
</script>
