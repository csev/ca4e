<h1>Mistic VLSI Layout</h1>
<div id="toolbar">
    <button onclick="setLayer('polysilicon')">Polysilicon</button>
    <button onclick="setLayer('N+ diffusion')">N+ Diffusion</button>
    <button onclick="setLayer('P+ diffusion')">P+ Diffusion</button>
    <button onclick="setLayer('contact')">Contact</button>
    <button onclick="setLayer('metal')">Metal</button>
    <button onclick="setLayer('VCC')">VCC</button>
    <button onclick="setLayer('GND')">GND</button>
    <button onclick="compute()">Compute</button>
    <button onclick="clearCanvas()">Clear All</button>
</div>
<canvas id="vlsiCanvas" width="400" height="400" style="border:1px solid #000000;"></canvas>

<script>
    const canvas = document.getElementById('vlsiCanvas');
    const ctx = canvas.getContext('2d');
    const tileSize = 20;
    const layers = {
        'polysilicon': 'rgba(255, 0, 0, 0.2)', // Light Red
        'N+ diffusion': 'rgba(0, 255, 0, 0.3)', // Light Green
        'P+ diffusion': 'rgba(255, 165, 0, 0.5)', // Light Orange
        'contact': 'rgba(0, 0, 0, 0.3)', // Light Black (not used for filling)
        'metal': 'rgba(0, 0, 255, 0.3)', // Light Blue
        'VCC': 'rgba(0, 0, 0, 0)', // Transparent for VCC
        'GND': 'rgba(0, 0, 0, 0)' // Transparent for GND
    };

    let currentLayer = '';
    let isDrawing = false;
    let startX, startY; // Track starting position
    const grid = Array(20).fill().map(() => Array(20).fill().map(() => Array(7).fill(false))); // 20x20x7 grid
    const volts = Array(20).fill().map(() => Array(20).fill().map(() => Array(7).fill(false)));

    function setLayer(layer) {
        currentLayer = layer;
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        grid.forEach(row => row.forEach(col => col.fill(false))); // Reset the grid
    }

    canvas.addEventListener('mousedown', function(event) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        startX = Math.floor((event.clientX - rect.left) / tileSize);
        startY = Math.floor((event.clientY - rect.top) / tileSize);
        
        // Handle the contact, VCC, and GND layers separately
        if (['contact', 'VCC', 'GND'].includes(currentLayer)) {
            grid[startY][startX][getLayerIndex('contact')] = false; // Mark the layer as drawn
            grid[startY][startX][getLayerIndex('VCC')] = false; // Mark the layer as drawn
            grid[startY][startX][getLayerIndex('GND')] = false; // Mark the layer as drawn

            grid[startY][startX][getLayerIndex(currentLayer)] = true; // Mark the layer as drawn
            redrawTile(startX, startY); // Redraw the tile immediately
            isDrawing = false; // Stop drawing after setting the layer
            return; // Exit early for these layers
        }
    });

    canvas.addEventListener('mousemove', function(event) {
        if (isDrawing && currentLayer !== 'contact' && currentLayer !== 'VCC' && currentLayer !== 'GND') { // Only draw rubber band if not contact, VCC, or GND
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / tileSize);
            const y = Math.floor((event.clientY - rect.top) / tileSize);
            drawRubberBand(startX, startY, x, y); // Draw the rubber band effect
        }
    });

    canvas.addEventListener('mouseup', function(event) {
        if (currentLayer !== 'contact' && currentLayer !== 'VCC' && currentLayer !== 'GND') { // Only fill tiles if not contact, VCC, or GND
            isDrawing = false;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((event.clientX - rect.left) / tileSize);
            const y = Math.floor((event.clientY - rect.top) / tileSize);
            fillTiles(startX, startY, x, y); // Fill or erase tiles once the mouse is released
        }
        ctx.beginPath(); // Reset the path
    });

    function drawRubberBand(startX, startY, endX, endY) {
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        redrawAllTiles(); // Redraw all tiles to maintain their state

        // Draw the rubber band rectangle
        const x1 = Math.min(startX, endX);
        const y1 = Math.min(startY, endY);
        const x2 = Math.max(startX, endX);
        const y2 = Math.max(startY, endY);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)'; // Rubber band color
        ctx.lineWidth = 2;
        ctx.strokeRect(x1 * tileSize, y1 * tileSize, (x2 - x1 + 1) * tileSize, (y2 - y1 + 1) * tileSize);
    }

    function fillTiles(startX, startY, endX, endY) {
        const x1 = Math.min(startX, endX);
        const y1 = Math.min(startY, endY);
        const x2 = Math.max(startX, endX);
        const y2 = Math.max(startY, endY);

        for (let i = y1; i <= y2; i++) {
            for (let j = x1; j <= x2; j++) {
                const layerIndex = getLayerIndex(currentLayer);
                if (currentLayer === 'erase') {
                    // Erase all layers at the current tile
                    for (let k = 0; k < 7; k++) {
                        grid[i][j][k] = false; // Mark all layers as not drawn
                    }
                } else if (layerIndex !== -1) {
                    grid[i][j][layerIndex] = true; // Mark the layer as drawn
                }
            }
        }
        redrawAllTiles(); // Redraw all tiles after filling or erasing
    }

    function redrawAllTiles() {
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                redrawTile(j, i); // Redraw each tile
            }
        }
    }

    function redrawTile(x, y) {
        ctx.clearRect(x * tileSize, y * tileSize, tileSize, tileSize); // Clear the tile
        let voltage = 0;
        for (let i = 0; i < 7; i++) { // Loop through all layers
            if (grid[y][x][i]) {
                if ( volts[y][x][i] == 1) {
                    voltage = 1;
                } else if ( volts[y][x][i] == -1) {
                    voltage = -1;
                }
                if (i === 3) { // If the layer is 'contact'
                    drawContactLines(x, y); // Draw the contact lines instead of filling
                } else if (i === 5) { // If the layer is 'VCC'
                    drawRectangle(x, y, 0);
                    drawText(x, y, 'V'); // Draw VCC text
                } else if (i === 6) { // If the layer is 'GND'
                    drawRectangle(x, y, 0);
                    drawText(x, y, 'G'); // Draw GND text
                } else {
                    ctx.fillStyle = Object.values(layers)[i]; // Get the color for the layer
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    if ( grid[y][x][3] || grid[y][x][5] || grid[y][x][6] ) {
                        // No voltage
                    } else {
                        if ( voltage == 1) {
                            drawText(x, y, '+');
                        } else if ( voltage == -1 ) {
                            drawText(x, y, '-');
                        }
                    }
                }
            }
        }
    }

    function drawRectangle(x, y, inset) {
        ctx.strokeStyle = 'black'; // Color for the lines
        ctx.lineWidth = 2; // Line width
        ctx.beginPath();
        // Draw a black rectangle for the contact, inset by 2.5 pixels (1/8 of tile size)
        ctx.strokeRect(x * tileSize + inset, y * tileSize + inset, tileSize - inset * 2, tileSize - inset * 2);
        ctx.stroke();
    }
    
    function drawContactLines(x, y) {
        const inset = tileSize / 4; 
        drawRectangle(x, y, inset);
        ctx.strokeStyle = 'black'; // Color for the lines
        ctx.lineWidth = 2; // Line width
        ctx.beginPath();
        ctx.moveTo(x * tileSize + inset, y * tileSize + inset);
        ctx.lineTo((x + 1) * tileSize - inset, (y + 1) * tileSize - inset); // Top-left to bottom-right
        ctx.moveTo((x + 1) * tileSize - inset, y * tileSize + inset);
        ctx.lineTo(x * tileSize + inset, (y + 1) * tileSize - inset); // Top-right to bottom-left
        ctx.stroke();
    }

    function drawText(x, y, text) {
        ctx.fillStyle = 'black'; // Color for the text
        ctx.font = 'bold 12px Arial'; // Font style
        ctx.textAlign = 'center'; // Center the text
        ctx.textBaseline = 'middle'; // Middle alignment
        ctx.fillText(text, x * tileSize + tileSize / 2, y * tileSize + tileSize / 2); // Draw the text in the center of the tile
    }

    function getLayerIndex(layer) {
        switch (layer) {
            case 'polysilicon': return 0;
            case 'N+ diffusion': return 1;
            case 'P+ diffusion': return 2;
            case 'contact': return 3;
            case 'metal': return 4;
            case 'VCC': return 5; // New layer index for VCC
            case 'GND': return 6; // New layer index for GND
            case 'erase': return -1; // Invalid layer for index
            default: return -1; // Invalid layer
        }
    }

    function compute() {
        // Reset the voltage of each tile
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                for (let l = 0; l < 7; l++) {
                    volts[i][j][l] = 0;
                }
            }
        }

        // Set all layers with VCC or GND to the correct voltage
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                if (grid[i][j][5]) {
                    for (let l = 0; l < 7; l++) {
                        volts[i][j][l] = 1;
                    }
                } else if (grid[i][j][6]) {
                    for (let l = 0; l < 7; l++) {
                        volts[i][j][l] = -1;
                    }
                }
            }
        }

        // Propogate metal down metal paths
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid[i].length; j++) {
                for (let l = 0; l < 7; l++) {
                    if (grid[i][j][l] && volts[i][j][l] != 0 ) {
                        propogateVoltage(volts[i][j][l], i-1, j, l);
                        propogateVoltage(volts[i][j][l], i, j-1, l);
                        propogateVoltage(volts[i][j][l], i+1, j, l);
                        propogateVoltage(volts[i][j][l], i, j+1, l);
                    }
                }
            }
        }

        // Set the voltage of the VCC and GND tiles
        redrawAllTiles();
    }

    function propogateVoltage(voltage, i, j, l) {
        // Have we stepped outside the tiles
        if ( i < 0 || i+1 > grid.length ) return;
        if ( j < 0 || j+1 > grid.length ) return;

        // Is the new tile conected to the current layer
        if ( ! grid[i][j][l] ) return;
        if ( volts[i][j][l] == voltage ) return;

        volts[i][j][l] = voltage;

        if ( i > 0 ) propogateVoltage(voltage, i-1, j, l);
        if ( j > 0 ) propogateVoltage(voltage, i, j-1, l);
        if ( i < grid.length-1 ) propogateVoltage(voltage, i+1, j, l);
        if ( j < grid.length-1 ) propogateVoltage(voltage, i, j+1, l);
    }

</script>
